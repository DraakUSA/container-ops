#!/bin/bash

# ==========================================
# 1. GLOBAL ENVIRONMENT SETUP
# ==========================================
# # Prevent Git-Bash path mangling for all commands
export MSYS_NO_PATHCONV=1

# Ensure USER is set for Docker volume paths
export USER=${USER:-$USERNAME}

# Set BASE_DIR relative to script location
BASE_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
cd "$BASE_DIR" || { echo "Failed to enter base directory"; exit 1; }

# 1. Use VISUAL or EDITOR if they exist
# 2. Otherwise, check if 'vi' is available in the path
# 3. Last resort: use the 'cmd /c start' trick for Windows GUI hand-off
if [ -n "$VISUAL" ]; then
    MY_EDITOR="$VISUAL"
elif [ -n "$EDITOR" ]; then
    MY_EDITOR="$EDITOR"
else
    MY_EDITOR="cmd //c start"
fi

# ==========================================
# 2. CONFIGURATION & STACK LOADING
# ==========================================
# Path to your stacks configuration
STACKS_FILE="stacks.txt"

# Read STACKS from file into an array
if [ -f "$STACKS_FILE" ]; then
    # Filter comments/blanks AND trim potential trailing whitespace
    mapfile -t STACKS < <(grep -v '^#' "$STACKS_FILE" | grep -v '^$' | sed 's/[[:space:]]*$//')
else
    echo "Error: $STACKS_FILE not found."
    exit 1
fi

# ==========================================
# 3. FUNCTIONS
# ==========================================
# Function to handle the starting logic
run_stack() {
  local stack_dir=$1
  echo "--- Processing $stack_dir ---"

  if [ -d "$stack_dir" ]; then
    cd "$stack_dir" || return

    # Check if a custom startup script exists
    if [ -f "./startup.sh" ]; then
      echo "--> Executing startup.sh..."
      ./startup.sh
    else
      echo "--> Running standard docker compose up..."
      docker compose up -d
    fi

    cd .. # Return to the base Docker directory
  else
    echo "Error: Directory $stack_dir not found."
  fi
}

# ==========================================
# 4. COMMAND LOGIC
# ==========================================
case "$1" in
  up)
    for stack in "${STACKS[@]}"; do
      run_stack "$stack"
    done
    echo ""
    $0 status  # This calls the status case within this same script
    ;;

  down)
    for stack in "${STACKS[@]}"; do
      echo "Stopping $stack..."
      (cd "$stack" && docker compose down)
    done
    ;;

  restart)
    for stack in "${STACKS[@]}"; do
      echo "Restarting $stack..."
      # For restart, we stop it normally, then use the run_stack function 
      # to ensure it restarts using the proper startup.sh logic
      (cd "$stack" && docker compose down)
      run_stack "$stack"
    done
    ;;

  logs)
    # Usage: ./manage.sh logs [stack_name] [-f]
    target_stack=$2
    shift 2
    extra_args=$@

    if [ -n "$target_stack" ]; then
       echo "Showing logs for $target_stack..."
       (cd "$target_stack" && docker compose logs $extra_args)
    else
       for stack in "${STACKS[@]}"; do
         echo "--- Logs for $stack ---"
         (cd "$stack" && docker compose logs --tail=20)
       done
    fi
    ;;

  check)
    for stack in "${STACKS[@]}"; do
      echo "--- Validating $stack ---"
      if [ -d "$stack" ]; then
        (
          cd "$stack" || exit
          # 'docker compose config' validates syntax and resolves variables
          docker compose config -q && echo "  [OK] Syntax is valid." || echo "  [ERROR] Check your YAML syntax."
        )
      else
        echo "  [SKIP] Directory $stack not found."
      fi
    done
    ;;

  prune)
    echo "This will remove all stopped containers, unused networks, and dangling images."
    read -p "Are you sure you want to proceed? (y/N): " confirm
    if [[ $confirm == [yY] ]]; then
        docker system prune -f
        echo "Cleanup complete."
    fi
    ;;

  discover)
    echo "Scanning for Docker stacks in $BASE_DIR..."
    
    # 1. Write the auto-generated header
    cat << EOF > "$STACKS_FILE"
########################################################################
# AUTO-GENERATED BY 'manage.sh discover'
# Generated on: $(date)
#
# Manual changes may be overwritten. To group stacks, edit this file
# and add custom headers, but be aware that running 'discover' again
# will reset the file layout.
########################################################################

EOF

    # 2. Find stacks, clean paths, and append to the file
    # We use -maxdepth 3 to catch 'networking/fing' style structures
    find . -maxdepth 3 -not -path '*/.*' -name "docker-compose.y*ml" -exec dirname {} \; | \
    sed 's|^\./||' | \
    sort -u >> "$STACKS_FILE"
    
    echo "--------------------------------------------------------"
    echo "Stacks discovered and saved to $STACKS_FILE"
    echo "--------------------------------------------------------"
    ;;

  edit)
    target=$2
    if [ -z "$target" ]; then
      $MY_EDITOR "$STACKS_FILE"
    else
      [ -d "$target" ] && $MY_EDITOR "$target/docker-compose.yml" || echo "Directory $target not found."
    fi
    ;;

  status|status-title)
    if [ "$1" == "status-title" ]; then
        echo "########################################################################"
        echo "#                                                                      #"
        echo "# Docker Container Status                                              #"
        echo "#                                                                      #"
        echo "########################################################################"
    fi
    docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}"
    if [ "$1" == "status-title" ]; then
        echo "########################################################################"
        echo ""
    fi
    ;;

  *)
    echo "Usage: $0 {up|down|restart|check|prune|status|status-title|discover|edit [stack]|logs [stack] [-f]}"
    exit 1
    ;;

esac

